<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QIR Adaptor Tool: Shorthand Notation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">QIR Adaptor Tool
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Shorthand Notation</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga75cc713660bd3bfdae9ed36001c31591"><td class="memItemLeft" align="right" valign="top"><a id="ga75cc713660bd3bfdae9ed36001c31591"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga75cc713660bd3bfdae9ed36001c31591">microsoft::quantum::notation::Capture::Capture</a> (std::string const &amp;name)</td></tr>
<tr class="memdesc:ga75cc713660bd3bfdae9ed36001c31591"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit creation using string name constructor. <br /></td></tr>
<tr class="separator:ga75cc713660bd3bfdae9ed36001c31591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga067f53b718d424ca59ec3b70a6b5c9b1"><td class="memItemLeft" align="right" valign="top"><a id="ga067f53b718d424ca59ec3b70a6b5c9b1"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>microsoft::quantum::notation::Capture::operator=</b> (IOperandPrototypePtr const &amp;other)</td></tr>
<tr class="separator:ga067f53b718d424ca59ec3b70a6b5c9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb463c16465034b9d9b85290edd9a4bc"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gabb463c16465034b9d9b85290edd9a4bc"><td class="memTemplItemLeft" align="right" valign="top">IOperandPrototypePtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">microsoft::quantum::notation::call</a> (std::string const &amp;name, Args... args)</td></tr>
<tr class="separator:gabb463c16465034b9d9b85290edd9a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1881ef24c25dfceb3ad71f18aa2c43f"><td class="memItemLeft" align="right" valign="top"><a id="gad1881ef24c25dfceb3ad71f18aa2c43f"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gad1881ef24c25dfceb3ad71f18aa2c43f">microsoft::quantum::notation::unnamedInvoke</a> ()</td></tr>
<tr class="memdesc:gad1881ef24c25dfceb3ad71f18aa2c43f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a invoke instruction. <br /></td></tr>
<tr class="separator:gad1881ef24c25dfceb3ad71f18aa2c43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70623d62fe54e6077fd102a33a93e5b"><td class="memTemplParams" colspan="2"><a id="gad70623d62fe54e6077fd102a33a93e5b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:gad70623d62fe54e6077fd102a33a93e5b"><td class="memTemplItemLeft" align="right" valign="top">IOperandPrototypePtr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gad70623d62fe54e6077fd102a33a93e5b">microsoft::quantum::notation::phi</a> (Args... args)</td></tr>
<tr class="memdesc:gad70623d62fe54e6077fd102a33a93e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a phi node with N arguments. <br /></td></tr>
<tr class="separator:gad70623d62fe54e6077fd102a33a93e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga766351375d479dbb164ee827ee330219"><td class="memItemLeft" align="right" valign="top">IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga766351375d479dbb164ee827ee330219">microsoft::quantum::notation::callByNameOnly</a> (std::string const &amp;name)</td></tr>
<tr class="separator:ga766351375d479dbb164ee827ee330219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad649d125a7dfa6d4fd594400b1638683"><td class="memItemLeft" align="right" valign="top"><a id="gad649d125a7dfa6d4fd594400b1638683"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gad649d125a7dfa6d4fd594400b1638683">microsoft::quantum::notation::bitCast</a> (IOperandPrototypePtr const  &amp;arg)</td></tr>
<tr class="memdesc:gad649d125a7dfa6d4fd594400b1638683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the llvm::BitCast instructruction. <br /></td></tr>
<tr class="separator:gad649d125a7dfa6d4fd594400b1638683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb76f23b9282dead50b4b5bf6c6ab64"><td class="memItemLeft" align="right" valign="top"><a id="gacdb76f23b9282dead50b4b5bf6c6ab64"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gacdb76f23b9282dead50b4b5bf6c6ab64">microsoft::quantum::notation::intToPtr</a> (IOperandPrototypePtr const  &amp;arg)</td></tr>
<tr class="memdesc:gacdb76f23b9282dead50b4b5bf6c6ab64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the llvm::IntToPtr instructruction. <br /></td></tr>
<tr class="separator:gacdb76f23b9282dead50b4b5bf6c6ab64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3374cd06fe2f3b4d9bff4ad23a4af4"><td class="memItemLeft" align="right" valign="top"><a id="gaea3374cd06fe2f3b4d9bff4ad23a4af4"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gaea3374cd06fe2f3b4d9bff4ad23a4af4">microsoft::quantum::notation::constInt</a> ()</td></tr>
<tr class="memdesc:gaea3374cd06fe2f3b4d9bff4ad23a4af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the llvm::ConstantInt instructruction. <br /></td></tr>
<tr class="separator:gaea3374cd06fe2f3b4d9bff4ad23a4af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad06c9d1eace6451c6cb6a80150b87576"><td class="memItemLeft" align="right" valign="top"><a id="gad06c9d1eace6451c6cb6a80150b87576"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gad06c9d1eace6451c6cb6a80150b87576">microsoft::quantum::notation::branch</a> (IOperandPrototypePtr const  &amp;cond, IOperandPrototypePtr const  &amp;arg1, IOperandPrototypePtr const  &amp;arg2)</td></tr>
<tr class="memdesc:gad06c9d1eace6451c6cb6a80150b87576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a branch instruction given a condition and two arguments. <br /></td></tr>
<tr class="separator:gad06c9d1eace6451c6cb6a80150b87576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8a0123f4724cb44f2484e7d8e38d086"><td class="memItemLeft" align="right" valign="top"><a id="gaa8a0123f4724cb44f2484e7d8e38d086"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><b>microsoft::quantum::notation::switchOp</b> (IOperandPrototypePtr const &amp;cond, IOperandPrototypePtr const &amp;arg1, IOperandPrototypePtr const &amp;arg2)</td></tr>
<tr class="separator:gaa8a0123f4724cb44f2484e7d8e38d086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b184fe960d85fd09167f16c833907b3"><td class="memItemLeft" align="right" valign="top"><a id="ga2b184fe960d85fd09167f16c833907b3"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga2b184fe960d85fd09167f16c833907b3">microsoft::quantum::notation::select</a> (IOperandPrototypePtr const &amp;cond, IOperandPrototypePtr const &amp;arg1, IOperandPrototypePtr const &amp;arg2)</td></tr>
<tr class="memdesc:ga2b184fe960d85fd09167f16c833907b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a select instruction given a condition and two arguments. <br /></td></tr>
<tr class="separator:ga2b184fe960d85fd09167f16c833907b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44ddd41276fac20964ede0e3b3a2c864"><td class="memItemLeft" align="right" valign="top"><a id="ga44ddd41276fac20964ede0e3b3a2c864"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga44ddd41276fac20964ede0e3b3a2c864">microsoft::quantum::notation::load</a> (IOperandPrototypePtr const  &amp;arg)</td></tr>
<tr class="memdesc:ga44ddd41276fac20964ede0e3b3a2c864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a load instruction with one argument. <br /></td></tr>
<tr class="separator:ga44ddd41276fac20964ede0e3b3a2c864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fb129cfb7135e02513ac0eea14b94bc"><td class="memItemLeft" align="right" valign="top">IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga2fb129cfb7135e02513ac0eea14b94bc">microsoft::quantum::notation::store</a> (IOperandPrototypePtr const &amp;target, IOperandPrototypePtr const &amp;value)</td></tr>
<tr class="separator:ga2fb129cfb7135e02513ac0eea14b94bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df4795986302aa16342db829b457071"><td class="memItemLeft" align="right" valign="top"><a id="ga1df4795986302aa16342db829b457071"></a>
IOperandPrototypePtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga1df4795986302aa16342db829b457071">microsoft::quantum::notation::basicBlock</a> ()</td></tr>
<tr class="memdesc:ga1df4795986302aa16342db829b457071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a load instruction with one argument. <br /></td></tr>
<tr class="separator:ga1df4795986302aa16342db829b457071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae89b441f450b5df53717bbf6f5c134c4"><td class="memItemLeft" align="right" valign="top">ReplacerFunction&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#gae89b441f450b5df53717bbf6f5c134c4">microsoft::quantum::notation::deleteInstruction</a> ()</td></tr>
<tr class="separator:gae89b441f450b5df53717bbf6f5c134c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga566037f3a56a77f63868af1ed5743731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmicrosoft_1_1quantum_1_1notation_1_1_capture.html">Capture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__shorthand_notation.html#ga566037f3a56a77f63868af1ed5743731">microsoft::quantum::notation::operator&quot;&quot;_cap</a> (char const *name, std::size_t)</td></tr>
<tr class="separator:ga566037f3a56a77f63868af1ed5743731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> get_one = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a>(<span class="stringliteral">&quot;__quantum__rt__result_get_one&quot;</span>);</div>
<div class="line">addRule(</div>
<div class="line">    {<a class="code" href="group__shorthand_notation.html#gad06c9d1eace6451c6cb6a80150b87576">branch</a>(<span class="stringliteral">&quot;cond&quot;</span>_cap = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a>(<span class="stringliteral">&quot;__quantum__rt__result_equal&quot;</span>, <span class="stringliteral">&quot;result&quot;</span>_cap = _, <span class="stringliteral">&quot;one&quot;</span>_cap =</div>
<div class="line">    get_one), _, _),</div>
<div class="line">     replace_branch_positive});</div>
<div class="ttc" id="agroup__shorthand_notation_html_gabb463c16465034b9d9b85290edd9a4bc"><div class="ttname"><a href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">microsoft::quantum::notation::call</a></div><div class="ttdeci">IOperandPrototypePtr call(std::string const &amp;name, Args... args)</div><div class="ttdef"><b>Definition:</b> Call.ipp:19</div></div>
<div class="ttc" id="agroup__shorthand_notation_html_gad06c9d1eace6451c6cb6a80150b87576"><div class="ttname"><a href="group__shorthand_notation.html#gad06c9d1eace6451c6cb6a80150b87576">microsoft::quantum::notation::branch</a></div><div class="ttdeci">IOperandPrototypePtr branch(IOperandPrototypePtr const &amp;cond, IOperandPrototypePtr const &amp;arg1, IOperandPrototypePtr const &amp;arg2)</div><div class="ttdoc">Matches a branch instruction given a condition and two arguments.</div><div class="ttdef"><b>Definition:</b> Branch.cpp:23</div></div>
</div><!-- fragment --><p>which matches IRs of the form</p>
<div class="fragment"><div class="line">%1 = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> %Result* @__quantum__rt__result_get_one()</div>
<div class="line">%2 = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)</div>
<div class="line">br i1 %2, label %then0__1, label %continue__1</div>
</div><!-- fragment --><p>The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: <code>cond</code>, <code>result</code> and <code>one</code> each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function).</p>
<p>The module further has shorthand notation for often encountered patterns such as any operand.</p>
<p>The module also implements shorthand notation for common replacers.</p>
<p>Literals which ease the burned of capturing values and increase readibility of the code. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabb463c16465034b9d9b85290edd9a4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb463c16465034b9d9b85290edd9a4bc">&#9670;&nbsp;</a></span>call()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IOperandPrototypePtr microsoft::quantum::notation::call </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand notations are made to make it possible to match patterns in the QIR. This part of the library focuses on making it easy to express advance patterns in just a few lines and specify what parts of the IR is of interest to the replacer function. An example is following pattern</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> get_one = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a>(<span class="stringliteral">&quot;__quantum__rt__result_get_one&quot;</span>);</div>
<div class="line">addRule(</div>
<div class="line">    {<a class="code" href="group__shorthand_notation.html#gad06c9d1eace6451c6cb6a80150b87576">branch</a>(<span class="stringliteral">&quot;cond&quot;</span>_cap = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a>(<span class="stringliteral">&quot;__quantum__rt__result_equal&quot;</span>, <span class="stringliteral">&quot;result&quot;</span>_cap = _, <span class="stringliteral">&quot;one&quot;</span>_cap =</div>
<div class="line">    get_one), _, _),</div>
<div class="line">     replace_branch_positive});</div>
</div><!-- fragment --><p>which matches IRs of the form</p>
<div class="fragment"><div class="line">%1 = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> %Result* @__quantum__rt__result_get_one()</div>
<div class="line">%2 = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> i1 @__quantum__rt__result_equal(%Result* %0, %Result* %1)</div>
<div class="line">br i1 %2, label %then0__1, label %continue__1</div>
</div><!-- fragment --><p>The pattern futher specifies that as a successful match is obtained, a table capturing certain values must be created. In the above example, the table would contain three entries: <code>cond</code>, <code>result</code> and <code>one</code> each of which would point to a a llvm::Value* in the QIR. This allows the replacement function to easily manipulate the DAG in these three places (four if you include the main captured value which is always passed to the replacement function). Shorthand notation to match an instruction for a function call. The resulting <a class="el" href="classmicrosoft_1_1quantum_1_1_i_operand_prototype.html">IOperandPrototype</a> matches a function call with arguments as specified by the arguments given. For instance,</p>
<div class="fragment"><div class="line">addRule({<a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a>(<span class="stringliteral">&quot;foo&quot;</span>, _, _), <a class="code" href="group__shorthand_notation.html#gae89b441f450b5df53717bbf6f5c134c4">deleteInstruction</a>()});</div>
<div class="ttc" id="agroup__shorthand_notation_html_gae89b441f450b5df53717bbf6f5c134c4"><div class="ttname"><a href="group__shorthand_notation.html#gae89b441f450b5df53717bbf6f5c134c4">microsoft::quantum::notation::deleteInstruction</a></div><div class="ttdeci">ReplacerFunction deleteInstruction()</div><div class="ttdef"><b>Definition:</b> Notation.cpp:21</div></div>
</div><!-- fragment --><p>matches a call to the function <code>foo</code> with exactly two arguments.</p>
<p>Shorthand notation to match an instruction for a function call. The resulting <a class="el" href="classmicrosoft_1_1quantum_1_1_i_operand_prototype.html">IOperandPrototype</a> matches a function call with arguments as specified by the arguments given. For instance,</p>
<div class="fragment"><div class="line">addRule({<a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a>(<span class="stringliteral">&quot;foo&quot;</span>, _, _), <a class="code" href="group__shorthand_notation.html#gae89b441f450b5df53717bbf6f5c134c4">deleteInstruction</a>()});</div>
</div><!-- fragment --><p>matches a call to the function <code>foo</code> with exactly two arguments. </p>

</div>
</div>
<a id="ga766351375d479dbb164ee827ee330219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga766351375d479dbb164ee827ee330219">&#9670;&nbsp;</a></span>callByNameOnly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IOperandPrototypePtr microsoft::quantum::notation::callByNameOnly </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand notation to match an instruction with a specified name. Unlike call, this pattern matches by name only and ignore the arguments.</p>
<div class="fragment"><div class="line">addRule({<a class="code" href="group__shorthand_notation.html#ga766351375d479dbb164ee827ee330219">callByNameOnly</a>(<span class="stringliteral">&quot;foo&quot;</span>), <a class="code" href="group__shorthand_notation.html#gae89b441f450b5df53717bbf6f5c134c4">deleteInstruction</a>()});</div>
<div class="ttc" id="agroup__shorthand_notation_html_ga766351375d479dbb164ee827ee330219"><div class="ttname"><a href="group__shorthand_notation.html#ga766351375d479dbb164ee827ee330219">microsoft::quantum::notation::callByNameOnly</a></div><div class="ttdeci">IOperandPrototypePtr callByNameOnly(std::string const &amp;name)</div><div class="ttdef"><b>Definition:</b> CallByNameOnly.cpp:23</div></div>
</div><!-- fragment --><p>matches calls to the function <code>foo</code> regardless of the number of arguments. </p>

</div>
</div>
<a id="gae89b441f450b5df53717bbf6f5c134c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae89b441f450b5df53717bbf6f5c134c4">&#9670;&nbsp;</a></span>deleteInstruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReplacerFunction microsoft::quantum::notation::deleteInstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shorthand notation to delete an instruction. If passed as the replacement function, this function generates a replacer that deletes the instruction. This is a shorthand notation for deleting an instruction that can be used with a custom rule when building a ruleset. This function can be used with shorthand notation for patterns as follows: </p><div class="fragment"><div class="line">addRule({<a class="code" href="group__shorthand_notation.html#ga766351375d479dbb164ee827ee330219">callByNameOnly</a>(name), <a class="code" href="group__shorthand_notation.html#gae89b441f450b5df53717bbf6f5c134c4">deleteInstruction</a>()});</div>
</div><!-- fragment --><p> to delete the instructions that calls functions with the name <code>name</code>. </p>

</div>
</div>
<a id="ga566037f3a56a77f63868af1ed5743731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga566037f3a56a77f63868af1ed5743731">&#9670;&nbsp;</a></span>operator&quot;&quot;_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmicrosoft_1_1quantum_1_1notation_1_1_capture.html">Capture</a> microsoft::quantum::notation::operator&quot;&quot;_cap </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Literal for specifying the capture of a llvm::Value*. This literal calls the IOperandPrototype::enableCapture through the assignment of a IOperandPrototypePtr to the class <a class="el" href="classmicrosoft_1_1quantum_1_1notation_1_1_capture.html">Capture</a>.</p>
<p>As an example, one may want to match the pattern <code>foo(bar(baz(x)), y)</code> and extract the variable <code>x</code> to add meta data to it. The corresponding IR could look like: </p><div class="fragment"><div class="line">%1 = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> %Type* @baz(%Type* %0)</div>
<div class="line">%2 = <a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> %Type* @bar(%Type* %1)</div>
<div class="line"><a class="code" href="group__shorthand_notation.html#gabb463c16465034b9d9b85290edd9a4bc">call</a> <span class="keywordtype">void</span> @foo(%Type* %2, %Type* %3)</div>
</div><!-- fragment --><p> To match this pattern, one would create the pattern <code>call("foo", call("bar", call("baz", "x"_cap = _)), _)</code>. This pattern would ensure that at the time where the replacer function is called, the value stored in <code>%0</code> is captured under the name <code>x</code>. </p>

</div>
</div>
<a id="ga2fb129cfb7135e02513ac0eea14b94bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fb129cfb7135e02513ac0eea14b94bc">&#9670;&nbsp;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IOperandPrototypePtr microsoft::quantum::notation::store </td>
          <td>(</td>
          <td class="paramtype">IOperandPrototypePtr const &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IOperandPrototypePtr const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matches a store instruction with a target and a value. </p><div class="fragment"><div class="line">addRule({<a class="code" href="group__shorthand_notation.html#ga2fb129cfb7135e02513ac0eea14b94bc">store</a>(<span class="stringliteral">&quot;target&quot;</span>_cap = _, <span class="stringliteral">&quot;value&quot;</span>_cap = _), replaceConstExpr});</div>
<div class="ttc" id="agroup__shorthand_notation_html_ga2fb129cfb7135e02513ac0eea14b94bc"><div class="ttname"><a href="group__shorthand_notation.html#ga2fb129cfb7135e02513ac0eea14b94bc">microsoft::quantum::notation::store</a></div><div class="ttdeci">IOperandPrototypePtr store(IOperandPrototypePtr const &amp;target, IOperandPrototypePtr const &amp;value)</div><div class="ttdef"><b>Definition:</b> Store.cpp:21</div></div>
</div><!-- fragment --><p> where we want to match all store instructions and do not really care about how the target or value came about. In this case, we may want to capture the values to, for instance, make assignment at compile time. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
